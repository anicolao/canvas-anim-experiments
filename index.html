<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Animation Performance Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background-color: black;
        }
        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        .stripe-canvas {
            position: absolute;
            top: 0;
            display: block;
            z-index: 1;
        }
        #stats {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            text-align: right;
            line-height: 1.5;
            pointer-events: none;
            z-index: 10;
        }
        #controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            line-height: 1.8;
            z-index: 10;
        }
        #controls label {
            display: block;
            margin-bottom: 8px;
        }
        #controls input[type="checkbox"] {
            margin-right: 5px;
        }
        #controls input[type="number"] {
            width: 60px;
            margin-left: 5px;
            background-color: #222;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 2px 5px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <label>
            <input type="checkbox" id="clearCanvas" checked>
            Clear whole canvas
        </label>
        <label>
            <input type="checkbox" id="useOffscreenCanvas">
            Render using offscreen canvas
        </label>
        <label>
            <input type="checkbox" id="disableAutoBuffering">
            Disable automatic double buffering
        </label>
        <label>
            Number of balls:
            <input type="number" id="ballCount" min="1" max="100" value="1">
        </label>
        <label>
            Stripes:
            <input type="number" id="stripes" min="1" max="100" value="1">
        </label>
    </div>
    <div id="stats">
        FPS: 0<br>
        Frame Time: 0ms
    </div>

    <script>
        // Canvas setup
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d', { desynchronized: false });
        const statsDiv = document.getElementById('stats');
        const clearCanvasCheckbox = document.getElementById('clearCanvas');
        const useOffscreenCanvasCheckbox = document.getElementById('useOffscreenCanvas');
        const disableAutoBufferingCheckbox = document.getElementById('disableAutoBuffering');
        const ballCountInput = document.getElementById('ballCount');
        const stripesInput = document.getElementById('stripes');

        // Function to create or recreate the canvas context with appropriate options
        function updateCanvasContext() {
            const contextOptions = {
                desynchronized: disableAutoBufferingCheckbox.checked
            };
            
            // To change the desynchronized attribute, we need to replace the canvas element
            const oldCanvas = canvas;
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'canvas';
            newCanvas.width = oldCanvas.width;
            newCanvas.height = oldCanvas.height;
            
            // Replace the canvas in the DOM
            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            
            // Update the global canvas reference
            canvas = newCanvas;
            
            // Get the new context with options
            ctx = canvas.getContext('2d', contextOptions);
        }

        // Handle checkbox change
        disableAutoBufferingCheckbox.addEventListener('change', () => {
            updateCanvasContext();
            updateStripeCanvases(); // Update stripe canvases too
            resizeCanvas();
        });

        // Offscreen canvas setup
        let offscreenCanvas = null;
        let offscreenCtx = null;

        // Stripe canvases
        let stripeCanvases = [];
        let stripeContexts = [];
        let stripeOffscreenCanvases = [];
        let stripeOffscreenContexts = [];
        let numStripes = 1;

        // Set canvas size to full window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Resize offscreen canvas if it exists
            if (offscreenCanvas) {
                offscreenCanvas.width = canvas.width;
                offscreenCanvas.height = canvas.height;
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Create stripe canvases based on the number of stripes
        function updateStripeCanvases() {
            const newNumStripes = parseInt(stripesInput.value) || 1;
            if (newNumStripes === numStripes && stripeCanvases.length > 0) {
                return; // No change needed
            }
            
            numStripes = newNumStripes;
            
            // Remove existing stripe canvases from DOM
            stripeCanvases.forEach(stripeCanvas => {
                if (stripeCanvas.parentNode) {
                    stripeCanvas.parentNode.removeChild(stripeCanvas);
                }
            });
            
            // Clear existing stripe canvases
            stripeCanvases = [];
            stripeContexts = [];
            stripeOffscreenCanvases = [];
            stripeOffscreenContexts = [];
            
            // Hide or show main canvas based on stripe count
            if (numStripes > 1) {
                canvas.style.display = 'none';
            } else {
                canvas.style.display = 'block';
            }
            
            const stripeWidth = canvas.width / numStripes;
            const contextOptions = {
                desynchronized: disableAutoBufferingCheckbox.checked
            };
            
            for (let i = 0; i < numStripes; i++) {
                // Create main stripe canvas
                const stripeCanvas = document.createElement('canvas');
                stripeCanvas.width = Math.ceil(stripeWidth);
                stripeCanvas.height = canvas.height;
                stripeCanvas.className = 'stripe-canvas';
                stripeCanvas.style.left = (i * stripeWidth) + 'px';
                stripeCanvas.style.width = Math.ceil(stripeWidth) + 'px';
                stripeCanvas.style.height = canvas.height + 'px';
                
                // Add to DOM only if using stripes
                if (numStripes > 1) {
                    document.body.appendChild(stripeCanvas);
                }
                
                stripeCanvases.push(stripeCanvas);
                stripeContexts.push(stripeCanvas.getContext('2d', contextOptions));
                
                // Create offscreen stripe canvas if needed
                if (useOffscreenCanvasCheckbox.checked) {
                    const offscreenStripeCanvas = document.createElement('canvas');
                    offscreenStripeCanvas.width = Math.ceil(stripeWidth);
                    offscreenStripeCanvas.height = canvas.height;
                    stripeOffscreenCanvases.push(offscreenStripeCanvas);
                    stripeOffscreenContexts.push(offscreenStripeCanvas.getContext('2d', contextOptions));
                } else {
                    stripeOffscreenCanvases.push(null);
                    stripeOffscreenContexts.push(null);
                }
            }
        }

        stripesInput.addEventListener('input', updateStripeCanvases);
        updateStripeCanvases(); // Initialize with default value

        // Create or destroy offscreen canvas based on checkbox state
        function updateOffscreenCanvas() {
            if (useOffscreenCanvasCheckbox.checked) {
                if (!offscreenCanvas) {
                    offscreenCanvas = document.createElement('canvas');
                    offscreenCanvas.width = canvas.width;
                    offscreenCanvas.height = canvas.height;
                    offscreenCtx = offscreenCanvas.getContext('2d');
                }
            } else {
                offscreenCanvas = null;
                offscreenCtx = null;
            }
            // Update stripe canvases to match offscreen setting
            updateStripeCanvases();
        }

        useOffscreenCanvasCheckbox.addEventListener('change', updateOffscreenCanvas);

        // Ball array
        let balls = [];

        // Function to create a ball with random position and velocity
        function createBall() {
            const colors = ['red', 'blue', 'green', 'yellow', 'cyan', 'magenta', 'orange', 'purple'];
            return {
                x: Math.random() * (canvas.width - 60) + 30,
                y: Math.random() * (canvas.height - 60) + 30,
                radius: 30,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                gravity: 0.5,
                damping: 0.95, // Energy loss on bounce
                color: colors[Math.floor(Math.random() * colors.length)]
            };
        }

        // Initialize with one ball
        balls.push(createBall());

        // Handle ball count changes
        ballCountInput.addEventListener('input', (e) => {
            const newCount = parseInt(e.target.value) || 1;
            const currentCount = balls.length;
            
            if (newCount > currentCount) {
                // Add new balls
                for (let i = 0; i < newCount - currentCount; i++) {
                    balls.push(createBall());
                }
            } else if (newCount < currentCount) {
                // Remove balls
                balls.length = newCount;
            }
        });

        // Performance tracking
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;
        let frameTimes = [];
        const maxFrameSamples = 60;

        // Try to show Chrome DevTools FPS meter programmatically
        // Note: This cannot be done programmatically for security reasons,
        // but we'll provide instructions in the console
        console.log('%c=== Canvas Animation Performance Test ===', 'color: #00ff00; font-size: 16px; font-weight: bold;');
        console.log('%cTo enable Chrome FPS meter:', 'color: #00aaff; font-size: 14px;');
        console.log('1. Open DevTools (F12 or Cmd+Option+I)');
        console.log('2. Press Cmd+Shift+P (Mac) or Ctrl+Shift+P (Windows/Linux)');
        console.log('3. Type "Show frames per second (FPS) meter"');
        console.log('4. Press Enter');
        console.log('%c=====================================', 'color: #00ff00; font-size: 16px; font-weight: bold;');

        function updateBall(ball, deltaTime) {
            // Apply gravity
            ball.vy += ball.gravity;

            // Update position
            ball.x += ball.vx;
            ball.y += ball.vy;

            // Bounce off walls
            if (ball.x + ball.radius > canvas.width) {
                ball.x = canvas.width - ball.radius;
                ball.vx = -ball.vx * ball.damping;
            } else if (ball.x - ball.radius < 0) {
                ball.x = ball.radius;
                ball.vx = -ball.vx * ball.damping;
            }

            // Bounce off floor and ceiling
            if (ball.y + ball.radius > canvas.height) {
                ball.y = canvas.height - ball.radius;
                ball.vy = -ball.vy * ball.damping;
            } else if (ball.y - ball.radius < 0) {
                ball.y = ball.radius;
                ball.vy = -ball.vy * ball.damping;
            }
        }

        function drawBall(ball, context) {
            context.beginPath();
            context.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            context.fillStyle = ball.color;
            context.fill();
            context.closePath();
        }

        function drawBallBackground(ball, context) {
            // Draw a small black background behind the ball
            const bgSize = ball.radius * 2.5;
            context.fillStyle = 'black';
            context.fillRect(ball.x - bgSize / 2, ball.y - bgSize / 2, bgSize, bgSize);
        }

        // Get which stripe(s) a ball belongs to
        function getBallStripes(ball) {
            const stripeWidth = canvas.width / numStripes;
            const leftEdge = ball.x - ball.radius;
            const rightEdge = ball.x + ball.radius;
            
            const leftStripe = Math.floor(leftEdge / stripeWidth);
            const rightStripe = Math.floor(rightEdge / stripeWidth);
            
            const stripes = [];
            for (let i = Math.max(0, leftStripe); i <= Math.min(numStripes - 1, rightStripe); i++) {
                stripes.push(i);
            }
            return stripes;
        }

        // Draw ball in a specific stripe context
        function drawBallInStripe(ball, stripeIndex) {
            const stripeWidth = canvas.width / numStripes;
            const stripeLeft = stripeIndex * stripeWidth;
            
            const renderCtx = stripeOffscreenContexts[stripeIndex] || stripeContexts[stripeIndex];
            
            // Translate ball position to stripe-local coordinates
            const localX = ball.x - stripeLeft;
            
            renderCtx.beginPath();
            renderCtx.arc(localX, ball.y, ball.radius, 0, Math.PI * 2);
            renderCtx.fillStyle = ball.color;
            renderCtx.fill();
            renderCtx.closePath();
        }

        // Draw ball background in a specific stripe context
        function drawBallBackgroundInStripe(ball, stripeIndex) {
            const stripeWidth = canvas.width / numStripes;
            const stripeLeft = stripeIndex * stripeWidth;
            
            const renderCtx = stripeOffscreenContexts[stripeIndex] || stripeContexts[stripeIndex];
            
            // Translate ball position to stripe-local coordinates
            const localX = ball.x - stripeLeft;
            const bgSize = ball.radius * 2.5;
            
            renderCtx.fillStyle = 'black';
            renderCtx.fillRect(localX - bgSize / 2, ball.y - bgSize / 2, bgSize, bgSize);
        }

        function updateStats(frameTime) {
            // Add frame time to array
            frameTimes.push(frameTime);
            if (frameTimes.length > maxFrameSamples) {
                frameTimes.shift();
            }

            // Calculate average frame time
            const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;

            // Update stats display
            statsDiv.innerHTML = `FPS: ${fps.toFixed(1)}<br>Frame Time: ${avgFrameTime.toFixed(2)}ms`;
        }

        function animate(currentTime) {
            const frameStartTime = performance.now();

            // Calculate delta time
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Update FPS counter
            frameCount++;
            if (frameCount >= 10) {
                fps = 1000 / (deltaTime || 1);
                frameCount = 0;
            }

            if (numStripes === 1) {
                // Single stripe mode - use original rendering logic
                const renderCtx = offscreenCtx || ctx;
                const targetCanvas = offscreenCanvas || canvas;

                // Clear canvas or draw backgrounds
                if (clearCanvasCheckbox.checked) {
                    // Clear the whole canvas (black background)
                    renderCtx.fillStyle = 'black';
                    renderCtx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);
                } else {
                    // Draw small black backgrounds behind each ball
                    balls.forEach(ball => drawBallBackground(ball, renderCtx));
                }

                // Update and draw all balls
                balls.forEach(ball => {
                    updateBall(ball, deltaTime);
                    drawBall(ball, renderCtx);
                });

                // If using offscreen canvas, copy to main canvas
                if (offscreenCanvas) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(offscreenCanvas, 0, 0);
                }
            } else {
                // Multi-stripe mode
                const stripeWidth = canvas.width / numStripes;

                // Clear all stripe canvases or draw backgrounds
                for (let i = 0; i < numStripes; i++) {
                    const renderCtx = stripeOffscreenContexts[i] || stripeContexts[i];
                    const targetCanvas = stripeOffscreenCanvases[i] || stripeCanvases[i];
                    
                    if (clearCanvasCheckbox.checked) {
                        // Clear the whole stripe canvas
                        renderCtx.fillStyle = 'black';
                        renderCtx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);
                    }
                }

                // Update all balls
                balls.forEach(ball => updateBall(ball, deltaTime));

                // Draw backgrounds if not clearing whole canvas
                if (!clearCanvasCheckbox.checked) {
                    balls.forEach(ball => {
                        const stripes = getBallStripes(ball);
                        stripes.forEach(stripeIndex => {
                            drawBallBackgroundInStripe(ball, stripeIndex);
                        });
                    });
                }

                // Draw all balls
                balls.forEach(ball => {
                    const stripes = getBallStripes(ball);
                    stripes.forEach(stripeIndex => {
                        drawBallInStripe(ball, stripeIndex);
                    });
                });

                // If using offscreen stripe canvases, copy them to the visible stripe canvases
                for (let i = 0; i < numStripes; i++) {
                    if (stripeOffscreenCanvases[i]) {
                        stripeContexts[i].clearRect(0, 0, stripeCanvases[i].width, stripeCanvases[i].height);
                        stripeContexts[i].drawImage(stripeOffscreenCanvases[i], 0, 0);
                    }
                }
            }

            // Calculate frame paint time
            const frameEndTime = performance.now();
            const frameTime = frameEndTime - frameStartTime;

            // Update stats
            updateStats(frameTime);

            // Continue animation
            requestAnimationFrame(animate);
        }

        // Start animation
        requestAnimationFrame(animate);
    </script>
</body>
</html>
